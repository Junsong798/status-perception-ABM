---
title: "triadic invasion"
output: html_document
date: "2025-07-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r triadic invasion status--retooled costs and benefits}

#-------------------------------------------------------------------
# Revised Triadic Status-vs-Form Invasion Model (fixed α)
#-------------------------------------------------------------------

# 0) Libraries
library(parallel)
library(dplyr)
library(ggplot2)

# 1) Parameter grid (now including alpha_update)
k_grid        <- c(1, 2, 5, 10, 20)
sigma_grid    <- c(0.1, 0.5, 1.0)
gamma_grid    <- c(5, 20, 50)
m_grid        <- c(3, 5, 10)
lambda_grid   <- c(0.5, 1.0, 2.0)

c_per_sample  <- 0.001    # cost per status sample
base_cost     <- 0.001    # cost per form bout
cost_factor   <- 0.25     # fight‐cost = γ * cost_factor
yield_factor  <- 0.5      # yielder loses ½·γ

param_tri <- expand.grid(
  N            = 100,
  k            = k_grid,
  sigma_status = sigma_grid,
  gamma        = gamma_grid,
  m            = m_grid,
  lambda       = lambda_grid,
  alpha_update = 0.1,         # **now included**
  stringsAsFactors = FALSE
) %>%
  mutate(
    cost_form = base_cost,
    cost_stat = c_per_sample * k,
    sigma_eff = sigma_status / sqrt(k)
  ) %>%
  rename(sigma = sigma_eff) %>%
  mutate(idx = row_number())

# 2) One-generation triadic function
run_triadic_generation <- function(
  pop_strat, s, WTR,
  k, sigma, gamma,
  cost_factor = 0.25,
  m = 5, lambda = 1,
  cost_form = 0.001, cost_stat = 0.005,
  yield_factor = 0.5,
  alpha = 0.1
) {
  N        <- length(s)
  payoffs  <- numeric(N)
  c_fight  <- gamma * cost_factor
  gamma_y  <- gamma * yield_factor

  bouts <- matrix(sample(N), ncol=2)[1:floor(N/2), ]

  for (b in seq_len(nrow(bouts))) {
    A <- bouts[b,1]; B <- bouts[b,2]
    others     <- setdiff(seq_len(N), c(A,B))
    bystanders <- sample(others, m)

    # decide fight probabilities
    decide_p <- function(i, opp) {
      if (pop_strat[i]=="form") {
        s[i]/(s[i]+s[opp])
      } else {
        S     <- rowMeans(WTR)
        est_i <- S[i]   + rnorm(1,0,sigma)
        est_o <- S[opp] + rnorm(1,0,sigma)
        exp(est_i)/(exp(est_i)+exp(est_o))
      }
    }
    fightA <- runif(1) < decide_p(A,B)
    fightB <- runif(1) < decide_p(B,A)

    # cognitive costs
    for (j in c(A,B,bystanders)) {
      payoffs[j] <- payoffs[j] -
        if (pop_strat[j]=="stat") cost_stat else cost_form
    }

    # outcome
    if (fightA && fightB) {
      # mutual fight
      if (runif(1) < s[A]/(s[A]+s[B])) {
        payoffs[A] <- payoffs[A] + gamma - c_fight
        payoffs[B] <- payoffs[B] - gamma - c_fight
        winner <- A; loser <- B
      } else {
        payoffs[B] <- payoffs[B] + gamma - c_fight
        payoffs[A] <- payoffs[A] - gamma - c_fight
        winner <- B; loser <- A
      }

    } else if (fightA) {
      # A fights alone
      payoffs[A] <- payoffs[A] + gamma - c_fight
      payoffs[B] <- payoffs[B] - gamma_y
      winner <- A; loser <- B

    } else if (fightB) {
      payoffs[B] <- payoffs[B] + gamma - c_fight
      payoffs[A] <- payoffs[A] - gamma_y
      winner <- B; loser <- A

    } else {
      # both yield
      payoffs[A] <- payoffs[A] - gamma_y
      payoffs[B] <- payoffs[B] - gamma_y
      next
    }

    # reputation (WTR) updates by all observers
    observers <- setdiff(seq_len(N), c(A,B))
    for (i in observers) {
      WTR[i,winner] <- WTR[i,winner] + alpha*(1 - WTR[i,winner])
      WTR[i,loser]  <- WTR[i,loser]  + alpha*(0 - WTR[i,loser])
    }
  }

  list(payoffs=payoffs, WTR=WTR)
}

# 3) Invasion‐fitness wrapper
one_invasion_run_tri <- function(idx, param) {
  p <- param[idx,]
  set.seed(idx)
  N   <- p$N
  s   <- runif(N)
  WTR <- matrix(0.5,N,N); diag(WTR)<-0

  # 1% stat invaders
  n_stat    <- max(1, round(0.01*N))
  pop_strat <- sample(c(rep("stat",n_stat), rep("form",N-n_stat)))

  # one generation
  res <- run_triadic_generation(
    pop_strat, s, WTR,
    k            = p$k,
    sigma        = p$sigma,
    gamma        = p$gamma,
    cost_factor  = cost_factor,
    m            = p$m,
    lambda       = p$lambda,
    cost_form    = p$cost_form,
    cost_stat    = p$cost_stat,
    yield_factor = yield_factor,
    alpha        = p$alpha_update
  )

  df <- data.frame(strat=pop_strat, payoff=res$payoffs)
  avg_stat <- mean(df$payoff[df$strat=="stat"])
  avg_form <- mean(df$payoff[df$strat=="form"])
  data.frame(idx=idx, avg_stat, avg_form)
}

# 4) Parallel sweep
n_reps <- 10
cl     <- makeCluster(detectCores()-1)
clusterEvalQ(cl, library(dplyr))
clusterExport(cl, c(
  "param_tri","run_triadic_generation",
  "one_invasion_run_tri","cost_factor","yield_factor"
))

total    <- nrow(param_tri)*n_reps
pb       <- txtProgressBar(0, total, style=3); cnt<-0
res_list <- vector("list", nrow(param_tri))

for(i in seq_len(nrow(param_tri))) {
  idxs <- rep(i, n_reps)
  block <- parLapplyLB(cl, idxs,
             function(ii) one_invasion_run_tri(ii, param_tri))
  dfb   <- bind_rows(block) %>%
           summarise(avg_stat=mean(avg_stat),
                     avg_form=mean(avg_form))
  res_list[[i]] <- cbind(
    param_tri[i,], fitness_diff = dfb$avg_stat - dfb$avg_form
  )
  cnt <- cnt + n_reps; setTxtProgressBar(pb, cnt)
}

stopCluster(cl); close(pb)
inv_tri <- bind_rows(res_list)

# 5) Extract ESS k
ess_tri <- inv_tri %>%
  group_by(sigma_status, gamma, m, lambda) %>%
  slice_max(fitness_diff, n=1, with_ties=FALSE) %>%
  ungroup() %>%
  dplyr::select(sigma_status, gamma, m, lambda, k, fitness_diff)

print(ess_tri)

# 6) (Optional) Heatmap of stat-vs-form advantage
ggplot(ess_tri,
       aes(x=factor(sigma_status),
           y=factor(gamma),
           fill=fitness_diff)) +
  geom_tile(color="grey80") +
  scale_fill_gradient2(
    low="blue", mid="white", high="red", midpoint=0,
    name=expression(Delta~Fitness[stat-form])
  ) +
  facet_grid(m~lambda, labeller=label_both) +
  labs(
    x=expression(sigma~"(noise)"),
    y=expression(gamma~"(stakes)"),
    title="Status vs. Form Invasion Advantage"
  ) +
  theme_minimal() +
  theme(panel.grid=element_blank())

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
